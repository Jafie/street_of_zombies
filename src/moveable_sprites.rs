use bevy::{
    prelude::*,
};


/// A sprite which is able to move
pub trait MoveableSprite {
    /// Get the current move speed of a moveable sprite in the game area
    ///
    /// # Examples
    ///
    /// ```
    /// let current_speed : f32 = my_moveable_sprit.get_speed();
    /// ```
    fn get_speed(&self) -> f32;

    /// Get the current direction of a moveable sprite in the game area
    ///
    /// # Examples
    ///
    /// ```
    /// let current_speed : f32 = my_moveable_sprit.get_direction();
    /// ```
    fn get_direction(&self) -> (f32, f32);

    
    /// Set the new direction of a moveable sprite
    ///
    /// # Arguments
    ///
    /// * `direction` - The new direction of your moveable sprite, set as (x, y)
    ///
    fn set_new_direction(&mut self, direction: (f32, f32));

    /// Get the current position of a moveable sprite in the game area
    fn get_position(&self) -> (f32, f32);

    /// Set the new position of a moveable sprite
    ///
    /// # Arguments
    ///
    /// * `position` - The new position of your moveable sprite, set as (x, y)
    ///
    fn set_new_position(&mut self, position: (f32, f32));

    /// Move the sprite to a new position.
    ///
    /// # Arguments
    ///
    /// * `time` - The timer provided by Bevy engine.
    /// * `direction` - The movement direction.
    /// * `translated_movement` - The "translated movement" returned to bevy engine.
    ///
    fn move_sprite(&mut self, time: &Res<Time>, direction: &(f32, f32), translated_movement: &mut bevy::prelude::Vec3) {
        // move the sprite
        translated_movement.x += time.delta_seconds() * direction.0 * &self.get_speed();
        translated_movement.y += time.delta_seconds() * direction.1 * &self.get_speed();
        self.set_new_position((translated_movement.x, translated_movement.y));
        self.set_new_direction(*direction);
    }
    /// Get the generic name of the sprite
    fn get_sprite_name() -> String;
}

/// Define a Weapon which is able to fire projectiles
pub trait Weapon {
    /// Create a new Weapon
    fn new() -> Self where Self: Sized;
    
    /// The generic fire command. Will generate a projectile following the weapon type defined
    ///
    /// # Arguments
    ///
    /// * `command` - The bevy command interface.
    /// * `materials` - The bevy material interface.
    /// * `direction` - The direction to fire the projectile.
    /// * `initial_pos` - The initial position of the projectile.
    ///
    fn fire_global(&mut self,
        commands: &mut Commands,
        materials: &mut ResMut<Assets<ColorMaterial>>,
        time: &mut ResMut<Time>,
        direction: (f32, f32),
        initial_pos: (f32, f32)) {

            if self.get_amo() > 0 && self.is_ready_to_fire(time.delta_seconds()){
            let (pos_x, pox_y) = initial_pos;
            commands
            .spawn_bundle(SpriteBundle {
                material: materials.add(Color::rgb(0.3, 0.0, 1.0).into()),
                transform: Transform::from_xyz(pos_x, pox_y, 0.0),
                sprite: Sprite::new(Vec2::new(5.0, 5.0)),
                ..Default::default()
            })
            .insert(self.create_projectile(direction, initial_pos));
            self.reduce_amo();
        }

    }

    /// Method to reload the weapon amo.
    fn reload(&mut self);

    /// Get the number of amo available in the weapon
    fn get_amo(&self) -> u32;

    /// Reduce the number of amo in the weapon by 1
    fn reduce_amo(&mut self);

    /// Get the fire rate of the weapon
    fn is_ready_to_fire(&mut self, time_elapsed_since_last_update: f32) -> bool;

    /// Create a new projectile
    ///
    /// # Arguments
    ///
    /// * `direction_to_set` - The direction of the projectile
    /// * `initial_position_to_set` - The initial position of the projectile
    ///
    fn create_projectile(&self, direction_to_set: (f32, f32), initial_position_to_set: (f32, f32)) -> Projectile;
}

/// A Pistol is a "Weapon", single fire
struct Pistol {
    /// Speed of the projectile
    speed: f32,
    /// Number of amo in the weapon
    amo: u32,
    /// Distance of fire of the projectiles generated by the weapon
    limit_of_fire: u32,
    /// The fire rate
    initial_fire_rate : f32,
    /// The fire rate
    current_fire_rate_timer : f32
}

impl Weapon for Pistol {
    fn new() -> Self {
        Pistol {speed: 500.0,
                amo: 856,
                limit_of_fire: 300,
                initial_fire_rate: 0.5,
                current_fire_rate_timer: 0.5}
    }

    fn reload(&mut self) {
        self.amo = 856;
    }
    fn get_amo(&self) -> u32 {
        self.amo
    }
    fn is_ready_to_fire(&mut self, time_elapsed_since_last_update: f32) -> bool {
        self.current_fire_rate_timer -= time_elapsed_since_last_update;

        if self.current_fire_rate_timer < 0.0 {
            self.current_fire_rate_timer = self.initial_fire_rate;
            return true;
        } 

        false
    }

    fn reduce_amo(&mut self) {
        self.amo -= 1;
    }
    fn create_projectile(&self, direction_to_set: (f32, f32), initial_position_to_set: (f32, f32)) -> Projectile {
        Projectile {
            speed: self.speed,
            direction: direction_to_set,
            initial_position : initial_position_to_set,
            current_position : initial_position_to_set,
            projectile_limit_distance: self.limit_of_fire,
        }
    }
}


/// The Main Character. Controllable by the player.
pub struct MainCharacter {
    speed: f32,
    current_position : (f32, f32),
    direction: (f32, f32),
    current_weapon: Box<dyn Weapon + Send + Sync>
}

impl MoveableSprite for MainCharacter {
    fn get_speed(&self) -> f32 {
        self.speed
    }
    fn set_new_direction(&mut self, direction: (f32, f32)) {
        self.direction = direction;
    }
    fn get_direction(&self) -> (f32, f32) {
        self.direction
    }
    fn get_position(&self) -> (f32, f32) {
        self.current_position
    }
    fn set_new_position(&mut self, position: (f32, f32)) {
        self.current_position = position;
    }
    fn get_sprite_name() -> String {
        String::from("Josay")
    }
}

impl MainCharacter {
    pub fn new(speed_to_set: f32, direction_to_set: (f32, f32), initial_pos: (f32, f32)) -> Self {
        MainCharacter {
             speed: speed_to_set,
             current_position: initial_pos,
             direction: direction_to_set,
             current_weapon: Box::new(Pistol::new())}
    }

    pub fn fire(&mut self,
        commands: &mut Commands,
        materials: &mut ResMut<Assets<ColorMaterial>>,
        time: &mut ResMut<Time>) {
            self.current_weapon.fire_global(commands, materials, time, self.get_direction(), self.get_position());
    }

    pub fn reload_weapon(&mut self) {
        self.current_weapon.reload();
    }
}

/// A projectile is generated by Weapons
pub struct Projectile {
    speed: f32,
    direction: (f32, f32),
    initial_position : (f32, f32),
    current_position : (f32, f32),
    projectile_limit_distance: u32,
}

impl Projectile {
    /// Return true if the Projectile browsed more than the "projectile_limit_distance"
    pub fn is_out_of_distance(&self) -> bool {
        let (initial_pos_x, initial_pos_y) = self.initial_position;
        let (current_pos_x, current_pos_y) = self.current_position;

        let position_diff_x = (current_pos_x - initial_pos_x) as i32;
        let position_diff_y = (current_pos_y - initial_pos_y) as i32;
        let distance_walked_squared = (position_diff_x.pow(2) + position_diff_y.pow(2)) as u32;

        let result = distance_walked_squared > self.projectile_limit_distance.pow(2);
        result
    }
}

impl MoveableSprite for Projectile {
    fn get_speed(&self) -> f32 {
        self.speed
    }
    fn set_new_direction(&mut self, direction: (f32, f32)) {
        self.direction = direction;
    }
    fn get_direction(&self) -> (f32, f32) {
        self.direction
    }
    fn get_position(&self) -> (f32, f32) {
        self.current_position
    }
    fn set_new_position(&mut self, position: (f32, f32)) {
        self.current_position = position;
    }
    fn get_sprite_name() -> String {
        String::from("Amo")
    }
}
