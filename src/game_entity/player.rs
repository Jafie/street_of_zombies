use crate::game_entity::MoveableSprite;
use crate::game_entity::MoveableSpriteTrait;

use crate::weapons::Pistol;
use crate::weapons::Weapon;

use bevy::prelude::*;
use bevy::ecs::component::Component;

// Default pistol weapon data
static PROJECTILE_SPEED: f32 = 700.0;
static AMO_IN_WEAPON: u32 = 800;
static LIMIT_OF_FIRE: u32 = 700;
static FIRE_RATE: f32 = 0.18;
static DEFAULT_PLAYER_HITBOX_SIZE: (f32, f32) = (35., 40.);

/// The Main Character entity, Controllable by the player. - A Player object contains all the information dedicated to a the player.
#[derive(Component)]
pub struct Player {
    sprite_data: MoveableSprite,
    player_data: PlayerInternal,
}

struct PlayerInternal {
    current_weapon: Box<dyn Weapon + Send + Sync>,
}

impl MoveableSpriteTrait for Player {
    fn get_moveable_interface(&self) -> &MoveableSprite {
        &self.sprite_data
    }

    fn get_moveable_interface_mut(&mut self) -> &mut MoveableSprite {
        &mut self.sprite_data
    }
}

impl Player {
    /// Returns a new Player object - A Player object contains all the information dedicated to a the player.
    ///
    /// # Arguments
    ///
    /// * `speed_to_set` - The speed of the player
    /// * `direction_to_set` - The direction of the player
    /// * `initial_pos` - The initial position of the player
    /// # Examples
    ///
    /// ```
    ///     let player = Player::new(500.0, (5., 10.), (15., 20.));
    /// ```
    pub fn new(speed_to_set: f32, direction_to_set: (f32, f32), initial_pos: (f32, f32)) -> Self {
        Player {
            player_data: PlayerInternal {
                current_weapon: Box::new(Pistol::new(
                    PROJECTILE_SPEED,
                    FIRE_RATE,
                    AMO_IN_WEAPON,
                    LIMIT_OF_FIRE,
                )),
            },
            sprite_data: MoveableSprite::new(
                speed_to_set,
                direction_to_set,
                initial_pos,
                DEFAULT_PLAYER_HITBOX_SIZE,
            ),
        }
    }

    /// Launch a Projectile with the player weapon
    ///
    /// # Arguments
    ///
    /// * `commands` - The bevy command object.
    /// * `time` - The timer generated by the bevy system.
    /// ```
    pub fn fire(
        &mut self,
        commands: &mut Commands,
        time: &Res<Time>,
    ) {
        self.player_data.current_weapon.fire_global(
            commands,
            time,
            self.sprite_data.get_direction(),
            self.sprite_data.get_position(),
            false,
            // Add a dummy argument if required by the trait
        );
    }

    /// Reload the player weapon
    ///
    /// # Examples
    ///
    /// ```
    ///     let player = Player::new(500.0, (5., 10.), (15., 20.));
    ///     player.reload_weapon()
    /// ```
    pub fn reload_weapon(&mut self) {
        self.player_data.current_weapon.reload();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn player_weapon_reload_test() {
        let mut player = Player::new(500.0, (5., 10.), (15., 20.));
        // Reload in case of "uncharged initial weapon"
        player.reload_weapon();
        let initial_amo = player.player_data.current_weapon.get_amo();
        player.player_data.current_weapon.reduce_amo();
        player.reload_weapon();
        assert_eq!(player.player_data.current_weapon.get_amo(), initial_amo);
    }
}
